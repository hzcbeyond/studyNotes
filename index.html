<!doctype html>
<html lang="Zh-cn">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
	<meta name="format-detection" content="telephone=no">
	<title>Git1</title>
	<!-- <link rel="stylesheet" type="text/css" href="CSS/style.css">
	<script type="text/javascript" src="js/script.js" ></script> -->
	<style>
		.content {
			width: 100px;
			height: 100px;
			display: flex;
			flex-direction: column;
			align-items: center;
			animation: anmait 5s linear infinite alternate;
			position: relative;
		}

		@keyframes anmait {
			from {
				left: 0px;
			}

			to {
				left: 100%;
			}
		}
	</style>
</head>

<body>
	<div class="content">
		<!-- <img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1045168275,4237832889&fm=200&gp=0.jpg" alt="" > -->
	</div>
	<script>
		//  reduce 方法的应用  reduce(previousValue, currentValue , index , array)
		// 1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
		// 2、currentValue （数组中当前被处理的元素）
		// 3、index （当前元素在数组中的索引）
		// 4、array （调用 reduce 的数组）

		// 1. 如未指定reduce方法的index的开始值默认只循环3次

		// var arr = [1, 2, 3, 4];
		// var sum = arr.reduce(function(prev, cur, index, arr) {
		// 	console.log(prev, cur, index);
		// 	return prev + cur;
		// })
		// console.log(arr, sum);

		// 2. 如指定 index 从 0 开始时 则默认循环 4 次  初始值 -> 即将处理的值 -> index值 (0 1 0) (1 2 1) (3 3 2) (6 4 3)

		// var arr = [1, 2, 3, 4];
		// var sum = arr.reduce(function (prev, cur, index, arr) {
		// 		console.log(prev, cur, index);
		// 		return prev + cur;
		// 	},0) //注意这里设置了初始值
		// console.log(arr, sum);

		// 3. 但当数组为空时使用reduce 则会出现报错 "TypeError: Reduce of empty array with no initial value"
		// var  arr = [];
		// var sum = arr.reduce(function(prev, cur, index, arr) {
		// 	console.log(prev, cur, index);
		// 	return prev + cur;
		// })
		// 但是要是我们设置了初始值就不会报错，如下：
		// var arr = [];
		// var sum = arr.reduce(function (prev, cur, index, arr) {
		// 	console.log(prev, cur, index);
		// 	return prev + cur;
		// }, 0)


		// reduce 简单用法 
		// let arr = [1,2,3,4];
		// let sum = arr.reduce((x,y) => x + y)
		// let mul = arr.reduce((x,y) => x * y)
		// console.log(sum,'总和', mul, '乘积')

		// reduce的高级用法
		//  (1) 计算数组中每个元素出现的次数
		// reduce((pre,cur)=>{ 
		// 	// doSomething ... 
		// },{})  
		// 后面所带的是 {} 返回的以对象形式 , 如是 [] 则返回数组形式的

		// let names = ['Bob','Alice','Nacy','Jack','Jack']
		// let nameNum = names.reduce((pre,cur) => {
		// 	if(cur in pre) {
		// 		// 判断对象是否为数组/对象的元素/属性：
		// 		// 格式：（变量 in 对象）......注意
		// 		// 当“对象”为数组时，“变量”指的是数组的“索引”；
		// 		// 当“对象”为对象是，“变量”指的是对象的“属性”。	

		// 		 pre[cur]++
		// 	}else {
		// 		 pre[cur] = 1
		// 	}
		// 	return pre
		// },{})
		// console.log(nameNum,'内容值')

		// (2) 数组去从   cur（下一个处理的值）
		// let arr = [1,2,3,4,5,6,7,8,8,8];
		// let setArr = arr.reduce((pre, cur) => {
		// 	if(!pre.includes(cur)){
		// 		return pre.concat(cur)
		// 	}else {
		// 		 return pre
		// 	}
		// },[])
		// console.log(setArr, '返回值')

		// (3) 将二维数组转化成一维数组
		// let arr = [[1,2],[2,3],[4,5]]
		// let newArr = arr.reduce((pre,cur) => {
		// 	 return pre.concat(cur) 
		// },[])
		// console.log(newArr,'返回值')

		// （4） 将多维数组转化成一维数组  递归方式
		// let arr = [ [0, 1], [2, 3], [4,[5,6,7]] ]
		// let newArr = function(val) {
		// 	return val.reduce((pre,cur) => { 
		// 	return pre.concat(Array.isArray(cur) ? newArr(cur) : cur)
		// },[])
		// }
		// console.log(newArr(arr),'返回值')

		// (5) 对象里的属性求和
		// let result = [
		// 	 {subject: 'math', scoure: 80},
		// 	 {subject: 'chinese', scoure: 20},
		// 	 {subject: 'english', scoure: 100}
		// ]
		// let num = result.reduce((pre,cur) => {
		// 	console.log(pre, '===',cur)
		// 	return cur.scoure + pre
		// },0)
		// console.log(num)

		// (7) 统计id相同的num值，并且只出现一次相同id）
		// let arr = [{
		// 	id: 1,
		// 	num: 23
		// }, {
		// 	id: 3,
		// 	num: 15
		// }, {
		// 	id: 1,
		// 	num: 37
		// }, {
		// 	id: 2,
		// 	num: 10
		// }];
		// let newArr = arr.reduce(function (prev, cur, index, arr) {
		// 	if (prev.findIndex(v => v.id == cur.id) >= 0) {
		// 		prev[prev.findIndex(v => v.id == cur.id)].num += cur.num
		// 		return prev
		// 	} else {
		// 		return prev.concat(cur)
		// 	}
		// }, [])
		// console.log(newArr)
	</script>
</body>

</html>